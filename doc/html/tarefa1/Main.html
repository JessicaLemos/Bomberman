<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Main</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Main.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption empty">&nbsp;</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>Safe</td></tr></table><p class="caption">Main</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Descrption: fun&#231;&#245;es que permitem a constru&#231;&#227;o do mapa
 Copyright: Ana Ribeiro
            J&#233;ssica Lemos </p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><a href="#v:mapa">mapa</a> :: Int -&gt; Int -&gt; [String]</li><li class="src short"><a href="#v:locPonto">locPonto</a> :: (Int, Int) -&gt; Int -&gt; [Int] -&gt; [Char]</li><li class="src short"><a href="#v:aConteudo">aConteudo</a> :: [Int] -&gt; [Char]</li><li class="src short"><a href="#v:locLinha">locLinha</a> :: (Int, Int) -&gt; Int -&gt; [Int] -&gt; [Char]</li><li class="src short"><a href="#v:juntaLinhas">juntaLinhas</a> :: (Int, Int) -&gt; Int -&gt; [Int] -&gt; [String]</li><li class="src short"><a href="#v:pontoPowerUp">pontoPowerUp</a> :: (Int, Int) -&gt; Int -&gt; [Int] -&gt; [[Char]]</li><li class="src short"><a href="#v:locBombs">locBombs</a> :: (Int, Int) -&gt; Int -&gt; [Int] -&gt; [String]</li><li class="src short"><a href="#v:juntaBombs">juntaBombs</a> :: (Int, Int) -&gt; Int -&gt; [Int] -&gt; [String]</li><li class="src short"><a href="#v:locFlames">locFlames</a> :: (Int, Int) -&gt; Int -&gt; [Int] -&gt; [String]</li><li class="src short"><a href="#v:juntaFlames">juntaFlames</a> :: (Int, Int) -&gt; Int -&gt; [Int] -&gt; [String]</li><li class="src short"><a href="#v:powerUps">powerUps</a> :: (Int, Int) -&gt; Int -&gt; [Int] -&gt; [String]</li><li class="src short"><a href="#v:converte">converte</a> :: (Int, Int) -&gt; Int -&gt; [Int] -&gt; [Char]</li><li class="src short"><a href="#v:nCelulasLinha">nCelulasLinha</a> :: (Int, Int) -&gt; Int -&gt; [Int] -&gt; Int</li><li class="src short"><a href="#v:nPedras">nPedras</a> :: Integral a =&gt; a -&gt; a</li><li class="src short"><a href="#v:nCelulas">nCelulas</a> :: Integral a =&gt; a -&gt; a</li><li class="src short"><a href="#v:semente">semente</a> :: Int -&gt; Int -&gt; [Int]</li><li class="src short"><a href="#v:locVazios">locVazios</a> :: (Int, Int) -&gt; Int -&gt; Bool</li><li class="src short"><a href="#v:main">main</a> :: IO ()</li></ul></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><a name="v:mapa" class="def">mapa</a> :: Int -&gt; Int -&gt; [String]</p><div class="doc"><p>A fun&#231;&#227;o &quot;mapa&quot; faz a jun&#231;&#227;o do mapa com os PowerUps. Dado que o mapa inicia na coordenada (0,0) &#224; dimens&#227;o retiramos um. </p></div></div><div class="top"><p class="src"><a name="v:locPonto" class="def">locPonto</a> :: (Int, Int) -&gt; Int -&gt; [Int] -&gt; [Char]</p><div class="doc"><p>A fun&#231;&#227;o &quot;locPonto&quot; indica para cada ponto do mapa se este &#233; pedra(&quot;#&quot;) ou vazio (&quot;&quot;). Tivemos em aten&#231;&#227;o que os extremos do mapa,
ou seja, a primeira e ultima colunas e linhas s&#227;o pedras. Posteriormente, recorremos &#224; fun&#231;&#227;o &quot;locVazios&quot; que indica as posi&#231;&#245;es 
dos vazios pr&#233;-definidos. Al&#233;m disto, verificamos que se a linha e a coluna forem pares encontra-se tamb&#233;m uma pedra. Nos restantes 
casos, verificamos se o conte&#250;do de cada ponto corresponde a um PowerUp (<code>+</code> ou <code>!</code>), um tijolo (<code>?</code>) ou um espa&#231;o vazio (' '). </p></div></div><div class="top"><p class="src"><a name="v:aConteudo" class="def">aConteudo</a> :: [Int] -&gt; [Char]</p><div class="doc"><p>&quot;aConteudo&quot; associa o n&#250;mero, proveniente do c&#225;lculo de numeros aleat&#243;rio recorrendo &#224; fun&#231;&#227;o &quot;semente&quot;, a um determinado conte&#250;do. 
Caso o n&#250;mero seja menor que 0 e 1 o seu conte&#250;do &#233; um PowerUp Bombs (<code>+</code>), entre 2 e 3 &#233; um PowerUo Flames (<code>!</code>), entre 3 e 39 &#233; um 
tijolo e osrestantes &#233; um espa&#231;o vazio. </p></div></div><div class="top"><p class="src"><a name="v:locLinha" class="def">locLinha</a> :: (Int, Int) -&gt; Int -&gt; [Int] -&gt; [Char]</p><div class="doc"><p>Esta fun&#231;&#227;o une todos os pontos de cada linha. Come&#231;amos por verificar se a &quot;locPonto&quot; &#233; pedra ou vazio pr&#233;-definido. Se o for, 
mantemos o ponto e recorremos de novo &#224; &quot;locLinha&quot; para verificar o ponto seguinte da linha. Desta forma, somamos 1 ao y e retiramos 
um valor &#224; sua dimen&#231;&#227;o uma vez que consideramos que cada linha tem d pontos sendo que o ultimo corresponde a d=0. Da&#237; um dos nossos 
casos de paragem ser locLinha (x,y) 0 l = &quot;#&quot;. Caso a &quot;locPonto&quot; corresponda a um PowerUp, recorresmos &#224; fun&#231;&#227;o &quot;converte&quot; uma vez 
que estes se encontram escondidos num tijolo e recorremos novamente &#224; &quot;locLinha&quot;. Note-se que neste caso eliminamos um elemento da 
lista que cont&#233;m os n&#250;meros aleat&#243;rios, dado que o primeiro n&#250;mero j&#225; foi associado. Aquando a &quot;locPonto&quot; est&#225; associada a um vazio
mantemos o ponto e fazemos a recursiva pelo mesmo m&#233;tedo anterior. Quando a lista dos n&#250;meros aleat&#243;rios se tornar vazia prosseguimos 
seguindo o mesmo processo.</p></div></div><div class="top"><p class="src"><a name="v:juntaLinhas" class="def">juntaLinhas</a> :: (Int, Int) -&gt; Int -&gt; [Int] -&gt; [String]</p><div class="doc"><p>A &quot;juntaLinhas&quot; faz a jun&#231;&#227;o de todas as linhas, recorrendo ao aumento de x. Enquanto a lista de n&#250;meros aleat&#243;rios n&#227;o for vazia 
vamos eliminando o n&#250;mero de pontos de cada linha que j&#225; foram associados. Dando origem ao mapa -</p></div></div><div class="top"><p class="src"><a name="v:pontoPowerUp" class="def">pontoPowerUp</a> :: (Int, Int) -&gt; Int -&gt; [Int] -&gt; [[Char]]</p><div class="doc"><p>A fun&#231;&#227;o d&#225; os PowerUps de determinados pontos. Caso a &quot;locPonto&quot; seja pedra ou um vazio pr&#233;-definido devolve-nos a lista vazia, 
uma vez que n&#227;o cont&#233;m PowerUps. O mesmo se verifica caso a &quot;locPonto&quot; n&#227;o seja um PowerUp. Se &quot;locPonto&quot; corresponder a um PowerUp 
ao s&#237;mbolo que lhe correspondo juntamos a coordenada do y e do x, utilizando a fun&#231;&#227;o show e seguindo a formata&#231;&#227;o definida. </p></div></div><div class="top"><p class="src"><a name="v:locBombs" class="def">locBombs</a> :: (Int, Int) -&gt; Int -&gt; [Int] -&gt; [String]</p><div class="doc"><p>Esta fun&#231;&#227;o junta todos os Bombs de determinada linha. Se a &quot;locPonto&quot; contiver um Bomb ent&#227;o recorre &#224; &quot;pontoPowerUp&quot; e prossegue 
para o ponto seguinte (da&#237; o y aumentar, a dimens&#227;o diminuir e ser eliminada a cabe&#231;a da lista). Aquando o ponto corresponde a uma pedras
ou vazio pr&#233;-definido, a fun&#231;&#227;o segue para o seguinte sem eliminar um elemento da lista (por n&#227;o ser utilizado). Nas seguintes situa&#231;&#245;es 
recorremos novamente &#224; &quot;locBombs&quot; para verificar o ponto seguinte com a elimina&#231;&#227;o de cabe&#231;as da lista. &#201; de salientar que sempre que 
chamamos a &quot;locPonto&quot; ao d somamos o y de modo a compensar a redu&#231;&#227;o da dimens&#227;o aplicada na recursividade da locBombs. </p></div></div><div class="top"><p class="src"><a name="v:juntaBombs" class="def">juntaBombs</a> :: (Int, Int) -&gt; Int -&gt; [Int] -&gt; [String]</p><div class="doc"><p>Esta junta os Bombs de todas linhas, recorrendo ao aumento de x. Isto &#233;, a fun&#231;&#227;o recorre &#224; &quot;locBombs&quot; e faz a recursiva para a 
linha seguinte. Enquanto a lista de n&#250;meros aleat&#243;rios n&#227;o for vazia vamos eliminando o n&#250;mero de pontos de cada linha que j&#225; foram 
associados. Quando a lista de n&#250;mero aleat&#243;rios for vazia devolve a lista vazia dado que, n&#227;o existem mais Bombs para juntar. </p></div></div><div class="top"><p class="src"><a name="v:locFlames" class="def">locFlames</a> :: (Int, Int) -&gt; Int -&gt; [Int] -&gt; [String]</p><div class="doc"><p>Esta fun&#231;&#227;o junta todos os Flames de determinada linha. Se a &quot;locPonto&quot; contiver um Flame ent&#227;o recorre &#224; &quot;pontoPowerUp&quot; e prossegue 
para o ponto seguinte (da&#237; o y aumentar, a dimens&#227;o diminuir e ser eliminada a cabe&#231;a da lista). Aquando o ponto corresponde a uma pedras
ou vazio pr&#233;-definido, a fun&#231;&#227;o segue para o seguinte sem eliminar um elemento da lista (por n&#227;o ser utilizado). Nas seguintes situa&#231;&#245;es 
recorremos novamente &#224; &quot;locBombs&quot; para verificar o ponto seguinte com a elimina&#231;&#227;o de cabe&#231;as da lista. &#201; de salientar que sempre que 
chamamos a &quot;locPonto&quot; ao d somamos o y de modo a compensar a redu&#231;&#227;o da dimens&#227;o aplicada na recursividade da locBombs. </p></div></div><div class="top"><p class="src"><a name="v:juntaFlames" class="def">juntaFlames</a> :: (Int, Int) -&gt; Int -&gt; [Int] -&gt; [String]</p><div class="doc"><p>Esta junta os Flames de todas linhas, recorrendo ao aumento de x. Isto &#233;, a fun&#231;&#227;o recorre &#224; &quot;locFlames&quot; e faz a recursiva para a 
linha seguinte. Enquanto a lista de n&#250;meros aleat&#243;rios n&#227;o for vazia vamos eliminando o n&#250;mero de pontos de cada linha que j&#225; foram 
associados. Quando a lista de n&#250;mero aleat&#243;rios for vazia devolve a lista vazia dado que, n&#227;o existem mais Flames para juntar. </p></div></div><div class="top"><p class="src"><a name="v:powerUps" class="def">powerUps</a> :: (Int, Int) -&gt; Int -&gt; [Int] -&gt; [String]</p><div class="doc"><p>A &quot;powerUps&quot; junta todos os Bombs e Flames, ordenados como pedido. </p></div></div><div class="top"><p class="src"><a name="v:converte" class="def">converte</a> :: (Int, Int) -&gt; Int -&gt; [Int] -&gt; [Char]</p><div class="doc"><p>Esta converte os s&#237;mbolos dos PowerUps em tijolos, visto que estes aparecem escondidos atr&#225;s de um tijolo no mapa. </p></div></div><div class="top"><p class="src"><a name="v:nCelulasLinha" class="def">nCelulasLinha</a> :: (Int, Int) -&gt; Int -&gt; [Int] -&gt; Int</p><div class="doc"><p>&quot;nCelulasLinha&quot; calcula o n&#250;mero de n&#250;meros aleat&#243;rios numa determinada linha. Note-se que a dimens&#227;o &#233; chamada com d-1. 
A primeira e &#250;ltima linha n&#227;o necessita de nenhum, uma vez que &#233; pedra. Na segunda e pen&#250;ltima linhas &#224; dimens&#227;o retiramos 
cinco, ou seja, dois vazios pr&#233;-definidos e duas pedras. Se a linha for impar &#224; dimens&#227;o refiramos um, ou seja, as duas pedras
dos extremos. No caso da terceira e antepen&#250;ltima linhas calculamos atrav&#233;s da express&#227;o (d+1)-((div (d+2) 2) +2), em que d 
corresponde &#224; dimens&#227;o. Nos restantes casos, (d+1)-(div (d+2) 2). </p></div></div><div class="top"><p class="src"><a name="v:nPedras" class="def">nPedras</a> :: Integral a =&gt; a -&gt; a</p><div class="doc"><p>Esta fun&#231;&#227;o indica o n&#250;mero de pedras do mapa, recorrendo apenas ao tamanho do mapa. </p></div></div><div class="top"><p class="src"><a name="v:nCelulas" class="def">nCelulas</a> :: Integral a =&gt; a -&gt; a</p><div class="doc"><p>A fun&#231;&#227;o nCelulas d&#225; o n&#250;mero de c&#233;luas que ir&#227;o ser associadas a um n&#250;mero. Para tal ao n&#250;mero total de pontos do mapa 
retiramos as pedras e os vazios pr&#233;-definidos. </p></div></div><div class="top"><p class="src"><a name="v:semente" class="def">semente</a> :: Int -&gt; Int -&gt; [Int]</p><div class="doc"><p>A &quot;semente&quot; gera um conjunto de n&#250;meros aleat&#243;rios tendo em conta a semente. Usamos a fun&#231;&#227;o &quot;nCelulas&quot; uma vez que apenas 
ser&#227;o associados n&#250;meros aleat&#243;rios a estes pontos. </p></div></div><div class="top"><p class="src"><a name="v:locVazios" class="def">locVazios</a> :: (Int, Int) -&gt; Int -&gt; Bool</p><div class="doc"><p>A fun&#231;&#227;o &quot;locVazios&quot; indica as posi&#231;&#245;es do vazios pr&#233;-definidos, tendo em conta que os vazios pr&#233;-definidos apenas se 
encontram nas linha um, dois, d-1 e d-2 e nas colunas um, dois, d-1 e d-2. Tivemos em aten&#231;&#227;o que as colunas n&#227;o podem ser 
ambas dois nem d-2. </p></div></div><div class="top"><p class="src"><a name="v:main" class="def">main</a> :: IO ()</p></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.16.1</p></div></body></html>